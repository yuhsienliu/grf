<!-- Generated by pkgdown: do not edit by hand -->
<!DOCTYPE html>
<html lang="en">
  <head>
  <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>The GRF Algorithm • grf</title>


<!-- jquery -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js" integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin="anonymous"></script>
<!-- Bootstrap -->

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha256-916EbMg70RQy9LHiGkXzG8hSg9EdNy97GazNG/aiY1w=" crossorigin="anonymous" />

<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha256-U5ZEeKfGNOja007MMD3YBI0A3OSZOQbeG6z2f2Y0hu8=" crossorigin="anonymous"></script>

<!-- Font Awesome icons -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.7.1/css/all.min.css" integrity="sha256-nAmazAk6vS34Xqo0BSrTb+abbtFlgsFK7NKSi6o7Y78=" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.7.1/css/v4-shims.min.css" integrity="sha256-6qHlizsOWFskGlwVOKuns+D1nB6ssZrHQrNj1wGplHc=" crossorigin="anonymous" />

<!-- clipboard.js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" integrity="sha256-FiZwavyI2V6+EXO1U+xzLG3IKldpiTFf3153ea9zikQ=" crossorigin="anonymous"></script>

<!-- headroom.js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.9.4/headroom.min.js" integrity="sha256-DJFC1kqIhelURkuza0AvYal5RxMtpzLjFhsnVIeuk+U=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.9.4/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script>

<!-- pkgdown -->
<link href="pkgdown.css" rel="stylesheet">
<script src="pkgdown.js"></script>



  
  <script src="extra.js"></script>

<meta property="og:title" content="The GRF Algorithm" />




<!-- mathjax -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script>

<!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->



  </head>

  <body>
    <div class="container template-title-body">
      <header>
      <div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="index.html">grf</a>
        <span class="version label label-default" data-toggle="tooltip" data-placement="bottom" title="Released version">1.0.1</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="articles/grf.html">Get started</a>
</li>
<li>
  <a href="reference/index.html">Reference</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Tutorials
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="articles/categorical_inputs.html">Categorical inputs</a>
    </li>
    <li>
      <a href="articles/ci_and_num.trees.html">Confidence intervals and the number of trees</a>
    </li>
    <li>
      <a href="articles/diagnostics.html">Evaluating a causal forest fit</a>
    </li>
    <li>
      <a href="articles/sample_weighting_examples.html">Sample weighting</a>
    </li>
  </ul>
</li>
<li>
  <a href="REFERENCE.html">Algorithm reference</a>
</li>
<li>
  <a href="DEVELOPING.html">Developing</a>
</li>
<li>
  <a href="CHANGELOG.html">Changelog</a>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li>
  <a href="https://github.com/grf-labs/grf">
    <span class="fa fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
      
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

      

      </header>

<div class="row">
  <div class="contents col-md-9">
    <div class="page-header">
      <h1>The GRF Algorithm</h1>
    </div>

<div id="the-grf-algorithm" class="section level1">

<p>The following guide gives an introduction to the generalized random forests algorithm as implemented in the <code>grf</code> package. It aims to give a complete description of the training and prediction procedures, as well as the options available for tuning. This guide is intended as an informal and practical reference; for a theoretical treatment of GRF, please consult the ‘Generalized Random Forests’ paper.</p>
<p>GRF extends the idea of a classic random forest to allow for estimating other statistical quantities besides the expected outcome. Each forest type, for example<code>quantile_forest</code>, trains a random forest targeted at a particular problem, like quantile estimation. The most common use of GRF is in estimating treatment effects through the function <code>causal_forest</code>.</p>
<div id="table-of-contents" class="section level2">
<h2 class="hasAnchor">
<a href="#table-of-contents" class="anchor"></a>Table of Contents</h2>
<ul>
<li>
<a href="#general-algorithm">General Algorithm</a>
<ul>
<li><a href="#training">Training</a></li>
<li><a href="#prediction">Prediction</a></li>
<li><a href="#out-of-bag-prediction">Out-of-bag Prediction</a></li>
<li><a href="#training-options">Training Options</a></li>
<li><a href="#variance-estimates">Variance Estimates</a></li>
</ul>
</li>
<li>
<a href="#causal-forests">Causal Forests</a>
<ul>
<li><a href="#orthogonalization">Orthogonalization</a></li>
<li><a href="#selecting-balanced-splits">Selecting Balanced Splits</a></li>
<li><a href="#average-treatment-effects">Average Treatment Effects</a></li>
<li><a href="#best-linear-projection-of-the-CATE">Best Linear Projection of the CATE</a></li>
</ul>
</li>
<li>
<a href="#additional-features">Additional Features</a>
<ul>
<li><a href="#parameter-tuning">Parameter Tuning</a></li>
<li><a href="#boosted-regression-forests">Boosted Regression Forests</a></li>
<li><a href="#cluster-robust-estimation">Cluster-Robust Estimation</a></li>
<li><a href="#sample-weighting">Sample Weighting</a></li>
<li><a href="#categorical-inputs">Categorical Inputs</a></li>
</ul>
</li>
<li><a href="#troubleshooting">Troubleshooting</a></li>
<li><a href="#references">References</a></li>
</ul>
</div>
<div id="general-algorithm" class="section level2">
<h2 class="hasAnchor">
<a href="#general-algorithm" class="anchor"></a>General Algorithm</h2>
<p>In this section, we describe GRF’s overall approach to training and prediction. The descriptions given in this section apply to all the available forest models. Specific details about the <code>causal_forest</code> method can be found in the ‘Causal Forests’ section below.</p>
<p>We begin with a simple example to illustrate the estimation process:</p>
<pre><code># Train a causal forest.
n = 2000; p = 10
X = matrix(rnorm(n*p), n, p)
W = rbinom(n, 1, 0.5)
Y = pmax(X[,1], 0) * W + X[,2] + pmin(X[,3], 0) + rnorm(n)
causal.forest = causal_forest(X, Y, W)

# Estimate causal effects on new test data.
X.test = matrix(0, 100, p)
X.test[,1] = seq(-2, 2, length.out = 100)
predictions = predict(causal.forest, X.test)$predictions

# Estimate causal effects for the training data using out-of-bag prediction.
oob.predictions = predict(causal.forest)$predictions</code></pre>
<p>We now explore each of these steps in more detail.</p>
<div id="training" class="section level3">
<h3 class="hasAnchor">
<a href="#training" class="anchor"></a>Training</h3>
<p>A random forest is at its core an ensemble model, composed of a group of decision trees. During training, a number of trees are grown on random subsamples of the dataset. Individual trees are trained through the following steps:</p>
<ul>
<li>First, a random subsample is drawn by sampling without replacement from the full dataset. A single root node is created containing this random sample.</li>
<li>The root node is split into child nodes, and child nodes are split recursively to form a tree. The procedure stops when no nodes can be split further. Each node is split using the following algorithm:
<ul>
<li>A random subset of variables are selected as candidates to split on.</li>
<li>For each of these variables <code>x</code>, we look at all of its possible values <code>v</code> and consider splitting it into two children based on this value. The goodness of a split (<code>x</code>, <code>v</code>) is determined by how much it increases heterogeneity in the quantity of interest. Certain splits are not considered, because the resulting child nodes would be too small or too different in size.</li>
<li>All examples with values for the split variable<code>x</code> that are less than or equal to the split value <code>v</code> are placed in a new left child node, and all examples with values greater than the <code>v</code> are placed in a right child node.</li>
<li>If a node has no valid splits, or if splitting will not result in an improved fit, the node is not split further and forms a leaf of the final tree.</li>
</ul>
</li>
</ul>
<p>The main difference between GRF’s approach to growing trees and that of classic random forests is in how the quality of a split is measured. Because the various forest types seek to estimate different statistical quantities like quantiles and treatment effects, splitting must be tailored to the particular task at hand. The approach taken in GRF is to maximize the heterogeneity in the quantity of interest across the child nodes. For example, with causal effect estimation, the goodness of a split relates to how different the treatment effect estimates are in each node. A theoretical motivation for this split criterion can be found in section 2 of the GRF paper.</p>
<p>The quality of a split must be calculated for each possible split variable <code>x</code> and value <code>v</code>, so it is critical for it to be fast to compute. Optimizing the heterogeneity criterion directly is therefore too expensive; instead, we take the gradient of the objective and optimize a linear approximation to the criterion. This approach allows us to reuse classic tree splitting algorithms that work in terms of cumulative sums. This gradient-based approach also has close ties to the concept of ‘influence functions’, as discussed in 2.3 of the GRF paper.</p>
</div>
<div id="prediction" class="section level3">
<h3 class="hasAnchor">
<a href="#prediction" class="anchor"></a>Prediction</h3>
<p>Given a test example, the GRF algorithm computes a prediction as follows:</p>
<ul>
<li>For each tree, the test example is ‘pushed down’ to determine what leaf it falls in.</li>
<li>Given this information, we create a list of neighboring training examples, weighted by how many times the example fell in the same leaf as the test example.</li>
<li>A prediction is made using this weighted list of neighbors, using the relevant approach for the type of forest. For regression forests, the prediction is equal to the average outcome of the test example’s neighbors. In causal prediction, we calculate the treatment effect using the outcomes and treatment status of the neighbor examples.</li>
</ul>
<p>Those familiar with classic random forests might note that this approach differs from the way forest prediction is usually described. The traditional view is that to predict for a test example, each tree makes a prediction on that example. To make a final prediction, the tree predictions are combined in some way, for example through averaging or through ‘majority voting’. It’s worth noting that for regression forests, the GRF algorithm described above is identical this ‘ensemble’ approach, where each tree predicts by averaging the outcomes in each leaf, and predictions are combined through a weighted average.</p>
</div>
<div id="out-of-bag-prediction" class="section level3">
<h3 class="hasAnchor">
<a href="#out-of-bag-prediction" class="anchor"></a>Out-of-bag Prediction</h3>
<p>If a dataset is provided to the <code>predict</code> method, then predictions are made for these new test example. When no dataset is provided, prediction proceeds on the training examples. In particular, for each training example, all the trees that did not use this example during training are identified (the example was ‘out-of-bag’, or OOB). Then, a prediction for the test example is made using only these trees. These out-of-bag predictions can be useful in understanding the model’s goodness-of-fit, and are also used in several of the methods for causal effect estimation methods described later in this guide.</p>
</div>
<div id="training-options" class="section level3">
<h3 class="hasAnchor">
<a href="#training-options" class="anchor"></a>Training Options</h3>
<div id="sample-fraction" class="section level4">
<h4 class="hasAnchor">
<a href="#sample-fraction" class="anchor"></a><code>sample.fraction</code>
</h4>
<p>The <code>sample.fraction</code> parameter is a number in the range (0, 1] that controls the fraction of examples that should be used in growing each tree. By default, <code>sample.fraction</code> is set to 0.5. As noted in the section on honest forests, the fractional subsample will be further split into halves when honesty is enabled.</p>
</div>
<div id="num-trees" class="section level4">
<h4 class="hasAnchor">
<a href="#num-trees" class="anchor"></a><code>num.trees</code>
</h4>
<p>The <code>num.trees</code> parameter controls how many trees are grown during training, and defaults to 2000. Tree training is parallelized across several threads in an effort to improve performance. By default, all available cores are used, but the number of threads can be set directly through <code>num.threads</code>.</p>
<p>Forests are a randomized ensemble algorithm, and as such every forest grown with a different initial seed will produce slightly different estimates, even when fit on the same data. We call this sort of perturbation error the <code>excess.error</code>, because it does not come from the inherent sampling variability in the data. Large forests have smaller <code>excess.error</code>, so we recommend that users grow as many trees as necessary to ensure that the values in <code>excess.error</code> are negligible relative to <code>variance.estimates</code>.</p>
<p>In addition, obtaining tighter confidence intervals requires growing even more trees than are needed for accurate predictions. When the number of trees in a forest is small, the confidence intervals can be too wide, and therefore too conservative. We recommend that users grow trees in proportion to the number of observations.</p>
<p>If you are interested in checking the evolution of <code>excess.error</code> or confidence interval widths as the number of trees increases, you can grow forests iteratively using the function <code>merge_forests</code> (see <a href="#merging-forests">Merging Forests</a> below).</p>
</div>
<div id="honesty-honesty-fraction-honesty-prune-leaves" class="section level4">
<h4 class="hasAnchor">
<a href="#honesty-honesty-fraction-honesty-prune-leaves" class="anchor"></a><code>honesty</code>, <code>honesty.fraction</code>, <code>honesty.prune.leaves</code>
</h4>
<p>By default, ‘honest’ forests are trained. The motivation behind honesty is to reduce bias in tree predictions, by using different subsamples for constructing the tree and for making predictions. Honesty is a well-explored idea in the academic literature on random forests, but is not yet common in software implementations. This section gives an algorithmic explanation of honesty; for a more formal overview, please see section 2.4 of Wager and Athey (2018).</p>
<p>In a classic random forest, a single subsample is used both to choose a tree’s splits, and for the leaf node examples used in making predictions. In contrast, honest forests randomly split this subsample in half, and use only the first half when performing splitting. The second half is then used to populate the tree’s leaf nodes: each new example is ‘pushed down’ the tree, and added to the leaf in which it falls. In a sense, the leaf nodes are ‘repopulated’ after splitting using a fresh set of examples.</p>
<p>After repopulating a tree’s leaves using the second half-sample, it is possible that some leaves end up empty. With empty leaves, a tree is not able to handle certain test examples and needs to be skipped when computing those predictions. By default, empty leaves are pruned away after training so that each tree is able to handle all test points. GRF’s behavior with respect to empty leaves can be controlled through the parameter <code>honesty.prune.leaves</code>.</p>
<p>It’s important to note that honesty may hurt performance when working with very small datasets. In this set-up, the subsample used to determine tree splits is already small, and honesty further cuts this subsample in half, so there may no longer be enough information to choose high-quality splits. There are a couple options for mitigating the cost of honesty in small samples:</p>
<ul>
<li>The parameter <code>honesty.fraction</code> allows for increasing the fraction of samples used in selecting tree splits. For example, an honesty fraction of 0.7 directs GRF to use 70% of the tree subsample for splitting, and the other 30% to populate the leaf nodes. If GRF is not working well on a small sample, we’ve found empirically that it can help to increase <code>honesty.fraction</code> and set <code>honesty.prune.leaves</code> to <code>FALSE</code>. With these settings, it may also be necessary to increase the number of trees grown in training through <code>num.trees</code>.</li>
<li>Alternatively, honesty can be completely disabled during training by setting the parameter <code>honesty</code> to <code>FALSE</code>.</li>
</ul>
<p>When automatically tuning parameters through <code>tune.parameters</code>, GRF will try varying <code>honesty.fraction</code> between 0.5 and 0.8, and consider both options for <code>honesty.prune.leaves</code>. More information on automatic parameter selection can be found in the ‘Parameter Tuning’ section below.</p>
</div>
<div id="mtry" class="section level4">
<h4 class="hasAnchor">
<a href="#mtry" class="anchor"></a><code>mtry</code>
</h4>
<p>The <code>mtry</code> parameter determines the number of variables considered during each split. The value of <code>mtry</code> is often tuned as a way to improve the runtime of the algorithm, but can also have an impact on statistical performance.</p>
<p>By default, <code>mtry</code> is taken as <code><a href="https://rdrr.io/r/base/Extremes.html">min(sqrt(p) + 20, p)</a></code>, where <code>p</code> is the number of variables (columns) in the dataset. This value can be adjusted by changing the parameter <code>mtry</code> during training. Selecting a tree split is often the most resource-intensive component of the algorithm. Setting a large value for <code>mtry</code> may therefore slow down training considerably.</p>
<p>To more closely match the theory in the GRF paper, the number of variables considered is actually drawn from a poisson distribution with mean equal to <code>mtry</code>. A new number is sampled from the distribution before every tree split.</p>
</div>
<div id="min-node-size" class="section level4">
<h4 class="hasAnchor">
<a href="#min-node-size" class="anchor"></a><code>min.node.size</code>
</h4>
<p>The parameter <code>min.node.size</code> relates to the minimum size a leaf node is allowed to have. Given this parameter, if a node reaches too small of a size during splitting, it will not be split further.</p>
<p>There are several important caveats to this parameter:</p>
<ul>
<li>When honesty is enabled, the leaf nodes are ‘repopulated’ after splitting with a fresh subsample. This means that the final tree may contain leaf nodes smaller than the <code>min.node.size</code> setting.</li>
<li>For regression forests, the splitting will only stop once a node has become smaller than <code>min.node.size</code>. Because of this, trees can have leaf nodes that violate the <code>min.node.size</code> setting. We initially chose this behavior to match that of other random forest packages like <code>randomForest</code> and <code>ranger</code>, but will likely be changed as it is misleading (see <a href="https://github.com/grf-labs/grf/issues/143">#143</a>).</li>
<li>When training a causal forest, <code>min.node.size</code> takes on a slightly different notion related to the number of treatment and control samples. More detail can be found in the ‘Split Penalization’ section below, under the ‘Causal Forests’ heading.</li>
</ul>
</div>
<div id="alpha" class="section level4">
<h4 class="hasAnchor">
<a href="#alpha" class="anchor"></a><code>alpha</code>
</h4>
<p>The parameter <code>alpha</code> controls the maximum imbalance of a split. In particular, when splitting a parent node, the size of each child node is not allowed to be less than <code>size(parent) * alpha</code>. Its value must lie between (0, 0.25), and defaults to 0.05.</p>
<p>When training a causal forest, this parameter takes on a slightly different notion related to the number of treatment and control samples. More detail can be found in the ‘Split Penalization’ section below, under the ‘Causal Forests’ heading.</p>
</div>
<div id="imbalance-penalty" class="section level4">
<h4 class="hasAnchor">
<a href="#imbalance-penalty" class="anchor"></a><code>imbalance.penalty</code>
</h4>
<p>The <code>imbalance.penalty</code> parameter controls how harshly imbalanced splits are penalized. When determining which variable to split on, each split is assigned a ‘goodness measure’ related to how much it increases heterogeneity across the child nodes. The algorithm applies a penalty to this value to discourage child nodes from having very different sizes, specified by <code>imbalance.penalty * (1.0 / size(left.child) + 1.0 / size(right.child)</code>. This penalty can be seen as a complement to the hard restriction on splits provided by <code>alpha</code>.</p>
<p>This parameter is still experimental, and unless <code>imbalance.penalty</code>is explicitly specified, it defaults to 0 so that no split penalty is applied.</p>
<p>When training a causal forest, this parameter takes on a slightly different notion related to the number of treatment and control samples. More detail can be found in the ‘Selecting Balanced Splits’ section below, under the ‘Causal Forests’ heading.</p>
</div>
</div>
<div id="variance-estimates" class="section level3">
<h3 class="hasAnchor">
<a href="#variance-estimates" class="anchor"></a>Variance Estimates</h3>
<p>By default, all forest models are trained in such a way as to support variance estimates. To calculate these estimates, the flag <code>estimate.variance</code> can be provided to prediction:</p>
<pre><code>causal.forest = causal_forest(X, Y, W)
prediction.result = predict(causal.forest, X.test, estimate.variance=TRUE)
standard.error = sqrt(prediction.result$variance.estimates)</code></pre>
<p>The procedure works by training trees in small groups, then comparing the predictions within and across groups to estimate variance. In more detail:</p>
<ul>
<li>In each training pass, we sample the full dataset to create a subsample of half its size. Then, a small group of trees in trained on this half-sample. In particular, for each tree we draw a subsample of the half-sample, and grow the tree using these examples.</li>
<li>When predicting, a variance estimate is also computed by comparing the variance in predictions within groups to the total variance. More details on the method can be found in section 4 of the GRF paper, or by examining the implementations of the C++ method <code>PredictionStrategy::compute_variance</code>.</li>
</ul>
<p>Note that although training starts by drawing a half-sample, the <code>sample.fraction</code> option still corresponds to a fraction of the full sample. This means that when variance estimates are requested, <code>sample.fraction</code> cannot be greater than 0.5.</p>
<p>The number of trees in each group is controlled through the <code>ci.group.size</code> parameter, and defaults to 2. If variance estimates are not needed, <code>ci.group.size</code> can be set to 1 during training to avoid growing trees in small groups.</p>
</div>
</div>
<div id="causal-forests" class="section level2">
<h2 class="hasAnchor">
<a href="#causal-forests" class="anchor"></a>Causal Forests</h2>
<p>The <code>causal.forest</code> method uses the same general training and prediction framework described above:</p>
<ul>
<li>When choosing a split, the algorithm seeks to maximize the difference in treatment effect between the two child nodes. For computational efficiency, we precompute the gradient of each observation, and optimize a linear approximation of this difference.</li>
<li>When predicting on a test example, we gather a weighted list of the sample’s neighbors based on what leaf nodes it falls in. We then calculate the treatment effect using the outcomes and treatment status of the neighbor examples. To speed up the algorithm, we precompute certain statistics in each leaf during training, such as the average value of the treatment.</li>
</ul>
<p>For a technical treatment of causal forest splitting and prediction, please refer to section 6.2 of the GRF paper.</p>
<p>Beyond this core training procedure, causal forests incorporate some additions specific to treatment effect estimation. These additions are described below.</p>
<div id="orthogonalization" class="section level3">
<h3 class="hasAnchor">
<a href="#orthogonalization" class="anchor"></a>Orthogonalization</h3>
<p>Recall that causal forests assume that potential outcomes are independent of treatment assignment, but only after we condition on features <code>X</code>. In this setting, in order to consistently estimate conditional average treatment effects, a naive causal forest would need to split both on features that affect treatment effects and those that affect treatment propensities. This can be wasteful, as splits ‘spent’ on modelling treatment propensities may not be useful in estimating treatment heterogeneity.</p>
<p>In GRF, we avoid this difficulty by ‘orthogonalizing’ our forest using Robinson’s transformation (Robinson, 1988). Before running <code>causal_forest</code>, we compute estimates of the propensity scores <code>e(x) = E[W|X=x]</code> and marginal outcomes <code>m(x) = E[Y|X=x]</code> by training separate regression forests and performing out-of-bag prediction. We then compute the residual treatment <code>W - e(x)</code> and outcome <code>Y - m(x)</code>, and finally train a causal forest on these residuals. If propensity scores or marginal outcomes are known through prior means (as might be the case in a randomized trial) they can be specified through the training parameters <code>W.hat</code> and <code>Y.hat</code>. In this case, <code>causal_forest</code> will use these estimates instead of training separate regression forests.</p>
<p>Empirically, we’ve found orthogonalization to be essential in obtaining accurate treatment effect estimates in observational studies. More details on the orthogonalization procedure in the context of forests can be found in section 6.1.1 of the GRF paper. For a broader discussion on Robinson’s transformation for conditional average treatment effect estimation, including formal results, please see Nie and Wager (2017).</p>
</div>
<div id="selecting-balanced-splits" class="section level3">
<h3 class="hasAnchor">
<a href="#selecting-balanced-splits" class="anchor"></a>Selecting Balanced Splits</h3>
<p>In the sections above on <code>min.node.size</code>, <code>alpha</code>, and <code>imbalance.penalty</code>, we described how tree training protects against making splits that result in a large size imbalance between the children, or leaf nodes that are too small. In a causal setting, it is not sufficient to consider the number of examples in each node – we must also take into account the number treatment vs. control examples. Without a reasonable balance of treated and control examples, there will not be enough information in the node to obtain a good estimate of treatment effect. In the worst case, we could end up with nodes composed entirely of control (or treatment) examples.</p>
<p>For this reason, causal splitting uses modified notions of each split balancing parameter:</p>
<ul>
<li>
<code>min.node.size</code> usually determines the minimum number of examples a node should contain. In causal forests, the requirement is more stringent: a node must contain at least <code>min.node.size</code> treated samples, and also at least that many control samples.</li>
<li>In regression forests, <code>alpha</code> and <code>imbalance.penalty</code> help ensure that the size difference between children is not too large. When applying <code>alpha</code> and <code>imbalance.penalty</code>, we use a modified measure of node size that tries to capture how much ‘information content’ it contains. The new size measure is given by <code>\sum_{i in node} (W_i - \bar{W})^2</code>.</li>
</ul>
<p>The above description of <code>min.node.size</code> assumes that the treatment is binary, which in most cases is an oversimplification. The precise algorithm for enforcing <code>min.node.size</code> is as follows. Note that this same approach is used both when the treatment is binary or continuous.</p>
<ul>
<li>Take the average of the parent node’s treatment values.</li>
<li>When considering a split, require that each child node have <code>min.node.size</code> samples with treatment value less than the average, and at least that many samples with treatment value greater than or equal to the average.</li>
</ul>
</div>
<div id="average-treatment-effects" class="section level3">
<h3 class="hasAnchor">
<a href="#average-treatment-effects" class="anchor"></a>Average Treatment Effects</h3>
<p>In addition to personalized treatment effects, causal forests can be used to estimate the average treatment effect across the training population. Naively, one might estimate the average treatment effect by averaging personalized treatment effects across training examples. However, a more accurate estimate can be obtained by plugging causal forest predictions into a doubly robust average treatment effect estimator. As discussed in Chernozhukov et al. (2018), such approaches can yield semiparametrically efficient average treatment effect estimates and accurate standard error estimates under considerable generality. GRF provides the dedicated function <code>average_treatment_effect</code> to compute these estimates.</p>
<p>The <code>average_treatment_effect</code> function implements two types of doubly robust average treatment effect estimations: augmented inverse-propensity weighting (Robins et al., 1994), and targeted maximum likelihood estimation (van der Laan and Rubin, 2006). Which method to use can be specified through the <code>method</code> parameter. The parameter <code>target.sample</code> controls which population the average treatment effect is taken over:</p>
<ul>
<li>
<code>target.sample = "all"</code>: the ATE on the whole population, <code>sum_{i = 1}^n E[Y(1) - Y(0) | X = X_i] / n</code>.</li>
<li>
<code>target.sample = "treated"</code>: the ATE on the treated examples, <code>sum_{W_i = 1} E[Y(1) - Y(0) | X = X_i] / |{i : W_i = 1}|</code>.</li>
<li>
<code>target.sample = "control"</code>: the ATE on the control examples, <code>sum_{W_i = 0} E[Y(1) - Y(0) | X = X_i] / |{i : W_i = 0}|</code>.</li>
<li>
<code>target.sample = "overlap"</code>: the overlap-weighted ATE <code>sum_{i = 1}^n e(Xi) (1 - e(Xi)) E[Y(1) - Y(0) | X = Xi] / sum_{i = 1}^n e(Xi) (1 - e(Xi))</code>, where <code>e(x) = P[W_i = 1 | X_i = x]</code>. This last estimand is recommended by Li et al. (2017) in case of poor overlap (i.e., when the treatment propensities e(x) may be very close to 0 or 1), as it doesn’t involve dividing by estimated propensities.</li>
</ul>
</div>
<div id="best-linear-projection-of-the-cate" class="section level3">
<h3 class="hasAnchor">
<a href="#best-linear-projection-of-the-cate" class="anchor"></a>Best Linear Projection of the CATE</h3>
<p>Sometimes, it is helpful to have a more expressive summary of the CATE function <code>tau(x) = E[Y(1) - Y(0) | X = x]</code> than the average treatment effect. One useful summary of this type is the “best linear projection” of tau(x) onto a set of features A, i.e., the population solution to the linear model</p>
<p><code>tau(X) ~ beta0 + A * beta</code></p>
<p>Qualitatively, these betas can be used to assess the association of the CATE function with the features A. The features A could, for example, be a subset of the features X used to train the forest. Note that, if the features A are mean zero, the intercept beta0 corresponds to the average treatment effect.</p>
<p>The function <code>best_linear_projection</code> provides estimates of the coefficients beta in the above model. Note that this function does not simply regress the CATE estimates tau.hat(Xi) given by the causal forest against Ai. Instead, we use a doubly robust estimator that generalizes the augmented inverse-propensity weighted estimator for the average treatment effect described above.</p>
</div>
</div>
<div id="additional-features" class="section level2">
<h2 class="hasAnchor">
<a href="#additional-features" class="anchor"></a>Additional Features</h2>
<p>The following sections describe other features of GRF that may be of interest.</p>
<div id="parameter-tuning" class="section level3">
<h3 class="hasAnchor">
<a href="#parameter-tuning" class="anchor"></a>Parameter Tuning</h3>
<p><strong>Note:</strong> tuning for <code>instrumental_forest</code> is considered ‘experimental’, and its implementation may change in future releases.</p>
<p>The accuracy of a forest can be sensitive to several training parameters:</p>
<ul>
<li>the core options tree-growing options <code>min.node.size</code>, <code>sample.fraction</code>, and <code>mtry</code>
</li>
<li>the parameters that control honesty behavior <code>honesty.fraction</code> and <code>honesty.prune.leaves</code>
</li>
<li>the split balance parameters <code>alpha</code> and <code>imbalance.penalty</code>
</li>
</ul>
<p>GRF provides a cross-validation procedure to select values of these parameters to use in training. To enable this tuning during training, the option <code>tune.parameters = "all"</code> can be passed to main forest method. The cross-validation methods can also be called directly through <code>tune_regression_forest</code> and <code>tune_causal_forest</code>. Parameter tuning is currently disabled by default.</p>
<p>The cross-validation procedure works as follows:</p>
<ul>
<li>Draw a number of random points in the space of possible parameter values. By default, 100 distinct sets of parameter values are chosen (<code>tune.num.reps</code>).</li>
<li>For each set of parameter values, train a forest with these values and compute the out-of-bag error. There are a couple important points to note about this error measure, outlined below. The exact procedure for computing the error can be found in the C++ methods that implement<code>OptimizedPredictionStrategy#compute_debiased_error</code>.
<ul>
<li>For tuning to be computationally tractable, we only train ‘mini forests’ composed of 50 trees (<code>tune.num.trees</code>). With such a small number of trees, the out-of-bag error gives a biased estimate of the final forest error. We therefore debias the error through a simple variance decomposition.</li>
<li>While the notion of error is straightforward for regression forests, it can be more subtle in the context of treatment effect estimation. For causal forests, we use a measure of error developed in Nie and Wager (2017) motivated by residual-on-residual regression (Robinson, 1988).</li>
</ul>
</li>
<li>Finally, given the debiased error estimates for each set of parameters, we apply a smoothing function to determine the optimal parameter values. The optimal parameters are the ones minimizing the predicted smoothed error on a new random draw of possible parameter values (of size <code>tune.num.draws</code>).</li>
</ul>
<p>Note that <code>honesty.fraction</code> and <code>honesty.prune.leaves</code> are only considered for tuning when <code>honesty = TRUE</code> (its default value). Parameter tuning does not try different options of <code>honesty</code> itself.</p>
<p>Tuning can be sensitive. Tuning only a subset of the parameters (with for example <code>tune.parameters = c("min.node.size", "honesty.prune.leaves")</code> may give better performance than trying to find the optimum for all. On smaller data, increasing <code>tune.num.trees</code> may not necessarily increase training time drastically and could result in more stable results.</p>
</div>
<div id="merging-forests" class="section level3">
<h3 class="hasAnchor">
<a href="#merging-forests" class="anchor"></a>Merging Forests</h3>
<p>In order to ensure valid predictions and tight confidence intervals, users may need to grow a large number of trees. However, it is hard to know exactly how many trees to grow in advance. That is why GRF allows users to grow their forests separately and then create a single forest using the function <code>merge_forests</code>. This functionality allows users to sequentially grow small forests, merge them into a large forest, and check if they have attained the desired level of <code>excess.error</code> or tight enough confidence intervals.</p>
</div>
<div id="boosted-regression-forests" class="section level3">
<h3 class="hasAnchor">
<a href="#boosted-regression-forests" class="anchor"></a>Boosted Regression Forests</h3>
<p><strong>Note:</strong> boosting is considered ‘experimental’, and its implementation may change in future releases.</p>
<p>Ghosal and Hooker (2018) show how a boosting step can reduce bias in random forest predictions. We provide a <code>boosted_regression_forest</code> method which trains a series of forests, each of which are trained on the OOB residuals from the previous step. <code>boosted_regression_forest</code> includes the same parameters as <code>regression_forest</code>, which are passed directly to the forest trained in each step.</p>
<p>The <code>boosted_regression_forest</code> method also contains parameters to control the step selection procedure. By default, the number of boosting steps is automatically chosen through the following cross-validation procedure:</p>
<ul>
<li>First, a single <code>regression_forest</code> is trained and added to the boosted forest.</li>
<li>To decide if another step should be taken, we train a small forest of size <code>boost.trees.tune</code> on the OOB residuals. If it’s estimated OOB error reduces the OOB error from the previous step by more than <code>boost.error.reduction</code>, then we will prepare for another step.</li>
<li>To take the next step, we train a full-sized <code>regression_forest</code> on the residuals and add it to the boosted forest.</li>
<li>This process continues until <code>boost.error.reduction</code> cannot be met when training the small forest, or if the total number of steps exceeds the limit <code>boost.max.steps</code>.</li>
</ul>
<p>Alternatively, you can to skip the cross-validation procedure and specify the number of steps directly through the parameter <code>boost.steps</code>.</p>
<p>By default, <code>causal_forest</code> uses <code>regression_forest</code> to perform orthogonalization (that is, estimating <code>e(x) = E[W|X=x]</code> and <code>m(x) = E[Y|X=x]</code>). If the <code>orthog.boosting</code> flag is enabled, then <code>boosted_regression_forest</code> will be used instead.</p>
<p>Some additional notes about the behavior of boosted regression forests:</p>
<ul>
<li>For computational reasons, if <code>tune.parameters</code> is enabled, then parameters are chosen by the <code>regression_forest</code> procedure once in the first boosting step. The selected parameters are then applied to train the forests in any further steps.</li>
<li>The <code>estimate.variance</code> parameter is not available for boosted forests.</li>
<li>OOB predictions are available for the training data, which combine the OOB predictions for the forests in each boosting step.</li>
<li>We have found that boosting improves out-of-bag forest predictions most in scenarios where there is a strong signal-to-noise ratio.</li>
</ul>
</div>
<div id="cluster-robust-estimation" class="section level3">
<h3 class="hasAnchor">
<a href="#cluster-robust-estimation" class="anchor"></a>Cluster-Robust Estimation</h3>
<p>For accurate predictions and variance estimates, it can be important to take into account for natural clusters in the data, as might occur if a dataset contains examples taken from the same household or small town. GRF provides support for cluster-robust forests by accounting for clusters in the subsampling process. To use this feature, the forest must be trained with the relevant cluster information by specifying the <code>clusters</code> and optionally the <code>equalize.cluster.weights</code> parameter. Then, all subsequent calls to <code>predict</code> will take clusters into account, including when estimating the variance of forest predictions.</p>
<p>When clustering is enabled during training, all subsampling procedures operate on entire clusters as opposed to individual examples. Then, to determine the examples used for performing splitting and populating the leaves, <code>samples_per_cluster</code> examples are drawn from the selected clusters. By default, <code>samples_per_cluster</code> is all the observations in the clusters. If <code>equalize.cluster.weights = TRUE</code> <code>samples_per_cluster</code> is equal to the size of the smallest cluster. Concretely, the cluster-robust training procedure proceeds as follows:</p>
<ul>
<li>If <code>estimate.variance</code> is enabled, sample half of the clusters. Each ‘tree group’ is associated with this half-sample of clusters (as described in the ‘Variance Estimates’ section). If we are not computing variance estimates, then keep the full sample instead.</li>
<li>Within this set of cluster IDs, sample <code>sample.fraction</code> of the clusters. Each tree is now associated with a list of cluster IDs.</li>
<li>If honesty is enabled, split these cluster IDs in half, so that one half can be used for growing the tree, and the other half is used in repopulating the leaves.</li>
<li>To grow the tree, draw <code>samples_per_cluster</code> examples from each of the cluster IDs, and do the same when repopulating the leaves for honesty.</li>
</ul>
<p>Note that when clusters are provided, standard errors from <code>average_treatment_effect</code> and <code>average_partial_effect</code> estimation are also cluster-robust. Moreover, If clusters are specified, then each unit gets equal weight by default. For example, if there are 10 clusters with 1 unit each and per-cluster ATE = 1, and there are 10 clusters with 19 units each and per-cluster ATE = 0, then the overall ATE is 0.05 (additional sample.weights allow for custom weighting). If equalize.cluster.weights = TRUE each cluster gets equal weight and the overall ATE is 0.5.</p>
</div>
<div id="sample-weighting" class="section level3">
<h3 class="hasAnchor">
<a href="#sample-weighting" class="anchor"></a>Sample Weighting</h3>
<p><strong>Note:</strong> this feature is currently marked ‘experimental’. Its implementation may change in future releases.</p>
<p>When the distribution of data that you observe is not representative of the population you are interested in scientifically, it can be important to adjust for this. We can pass <code>sample.weights</code> to specify that in our population of interest, we observe Xi with probability proportional to <code>sample.weights[i]</code>. By default, these weights are constant, meaning that our population of interest is the population from which X1 … Xn are sampled. For causal validity, the weights we use should not be confounded with the potential outcomes — typically this is done by having them be a function of Xi. One common example is inverse probability of complete case weighting to adjust for missing data, which allows us to work with only the complete cases (the units with nothing missing) to estimate properties of the full data distribution (all units as if nothing were missing).</p>
<p>The impact these weights have depends on what we are estimating. When our estimand is a function of x, e.g. <code>r(x) = E[Y | X=x]</code> in <code>regression_forest</code> or <code>tau(x)=E[Y(1)-Y(0)| X=x]</code> in <code>causal_forest</code>, passing weights that are a function of x does not change our estimand. It instead prioritizes fit on our population of interest. In <code>regression_forest</code>, this means minimizing weighted mean squared error, i.e. mean squared error over the population specified by the sample weights. In <code>causal_forest</code>, this means minimizing weighted R-loss (Nie and Wager (2017), Equations 4/5). When our estimand is an average of such a function, as in <code>average_treatment_effect</code> and <code>average_partial_effect</code>, it does change the estimand. Our estimand will be the average treatment/partial effect over the population specified by our sample weights.</p>
</div>
<div id="categorical-inputs" class="section level3">
<h3 class="hasAnchor">
<a href="#categorical-inputs" class="anchor"></a>Categorical inputs</h3>
<p>GRF can only handle numerical inputs. If your data has a column with categorical values, here are some ways in which you can proceed.</p>
<p>If there is a natural way to order the categories, then simply encode them as integers according to this ordering. For instance, an individual’s educational attainment could be encoded as 1 for “primary”, 2 for “secondary”, 3 for “undergraduate”, and so on. This representation will make it easy for forests to split individuals into lower and higher education groups. Moreover, even if your variable does not have an obvious ordering at first sight, you may want to be a little creative in imposing an artificial ordering that is relevant to your statistical problem. For example, numbering contiguous geographical areas sequentially can often help forests make splits that group nearby areas together. If geographical proximity is important, the forest performance will likely increase.</p>
<p>However, sometimes the category has no reasonable ordering. In that case, one common option is to create one-hot encoded vectors (also know as dummy vectors), replacing the column with several binary columns indicating the category to which each observation belongs. Unfortunately, this sort of representation can be wasteful, because each binary column will likely not carry a lot of information. When the number of categories is large, you might want to use a more sophisticated representation method such as feature hashing. Alternatively, we recommend users try our sister package <a href="https://github.com/grf-labs/sufrep"><code>sufrep</code></a>, which implements several categorical variable representation methods. It is currently in beta version, so please feel free to submit github issues for bugs or additional feature requests.</p>
<p>Finally, please bear in mind that in general the statistical performance of any statistical algorithm will depend on how the data is represented. Therefore, it may be worthwhile to spend some time thinking about how to encode your variables before starting the actual analysis.</p>
</div>
</div>
<div id="troubleshooting" class="section level2">
<h2 class="hasAnchor">
<a href="#troubleshooting" class="anchor"></a>Troubleshooting</h2>
<div id="grf-isnt-working-well-on-a-small-dataset-" class="section level3">
<h3 class="hasAnchor">
<a href="#grf-isnt-working-well-on-a-small-dataset-" class="anchor"></a>GRF isn’t working well on a small dataset.</h3>
<p>If you observe poor performance on a dataset with a small number of examples, there are two changes worth looking into:</p>
<ul>
<li>Adjusting honesty parameters during training. When honesty is enabled, the training subsample is further split in half before performing splitting. This may not leave enough information for the algorithm to determine high-quality splits. The section above on the <code>honesty</code> parameter gives guidance on how to mitigate the issue.</li>
<li>Skipping the variance estimate computation by setting <code>ci.group.size</code> to 1 during training, then increasing <code>sample.fraction</code>. Because of how variance estimation is implemented, <code>sample.fraction</code> cannot be greater than 0.5 when it is enabled. If variance estimates are not needed, it may help to disable this computation and use a larger subsample size for training.</li>
</ul>
</div>
<div id="the-variance-estimates-are-jumpy-or-very-large-" class="section level3">
<h3 class="hasAnchor">
<a href="#the-variance-estimates-are-jumpy-or-very-large-" class="anchor"></a>The variance estimates are jumpy or very large.</h3>
<p>In this case, it would be good to try growing a larger number of trees. Obtaining good variance estimates often requires growing more trees than it takes to only obtain accurate predictions. See the discussion under <a href="#numtrees"><code>num.trees</code></a> and <a href="#merging-forests">Merging Forests</a>.</p>
</div>
<div id="the-causal-forest-method-is-producing-nonsensical-results-" class="section level3">
<h3 class="hasAnchor">
<a href="#the-causal-forest-method-is-producing-nonsensical-results-" class="anchor"></a>The causal forest method is producing nonsensical results.</h3>
<p>If the output of the <code>causal.forest</code> method doesn’t pass a sanity check based on your knowledge of the data, it may be worth checking whether the overlap assumption is violated. In order for conditional average treatment effects to be properly identified, a dataset’s propensity scores must be bounded away from 0 and 1. A simple way to validate this assumption is to calculate the propensity scores by regressing the treatment assignments W against X, and examining the out-of-bag predictions. Concretely, you can perform the following steps:</p>
<pre><code>propensity.forest = regression_forest(X, W)
W.hat = predict(propensity.forest)$predictions
hist(W.hat, xlab = "propensity score")</code></pre>
<p>If there is strong overlap, the histogram will be concentrated away from 0 and 1. If the data is instead concentrated at the extremes, the overlap assumption likely does not hold.</p>
<p>For further discussion of the overlap assumption, please see Imbens and Rubin (2015). In practice, this assumption is often violated due to incorrect modelling decision: for example one covariate may be a deterministic indicator that the example received treatment.</p>
</div>
<div id="regression-forest-predictions-differ-from-those-of-the-randomforest-and-ranger-packages-" class="section level3">
<h3 class="hasAnchor">
<a href="#regression-forest-predictions-differ-from-those-of-the-randomforest-and-ranger-packages-" class="anchor"></a>Regression forest predictions differ from those of the randomForest and ranger packages.</h3>
<p>While the algorithm in <code>regression_forest</code> is very similar to that of classic random forests, it has several notable differences, including ‘honesty’, group tree training for variance estimates, and restrictions during splitting to avoid imbalanced child nodes. These features can cause the predictions of the algorithm to be different, and also lead to a slower training procedure than other packages. We welcome GitHub issues that shows cases where GRF does notably worse than other packages (either in statistical or computational performance), as this will help us choose better defaults for the algorithm, or potentially point to a bug.</p>
</div>
<div id="forests-predict-different-values-depending-on-the-platform-even-though-the-seed-is-the-same" class="section level3">
<h3 class="hasAnchor">
<a href="#forests-predict-different-values-depending-on-the-platform-even-though-the-seed-is-the-same" class="anchor"></a>Forests predict different values depending on the platform even though the seed is the same</h3>
<p>Overall, GRF is designed to produce the same estimates across platforms when using a consistent value for the random seed through the training option seed. However, there are still some cases where GRF can produce different estimates across platforms. When it comes to cross-platform predictions, the output of GRF will depend on a few factors beyond the forest seed.</p>
<p>One such factor is the compiler that was used to build GRF. Different compilers may have different default behavior around floating-point rounding, and these could lead to slightly different forest splits if the data requires numerical precision. Another factor is how the forest construction is distributed across different threads. Right now, our forest splitting algorithm can give different results depending on the number of threads that were used to build the forest.</p>
<p>Therefore, in order to ensure consistent results, we provide the following recommendations.</p>
<ul>
<li>Make sure arguments <code>seed</code> and <code>num.threads</code> are the same across platforms</li>
<li>Round data to 8 significant digits</li>
</ul>
<p>Also, please note that we have not done extensive testing on Windows platforms, although we do not expect random number generation issues there to be different from Linux/Mac. Regardless of the platform, if results are still not consistent please help us by submitting a Github issue.</p>
</div>
</div>
<div id="references" class="section level2">
<h2 class="hasAnchor">
<a href="#references" class="anchor"></a>References</h2>
<p>Athey, Susan, Julie Tibshirani and Stefan Wager. Generalized Random Forests, <em>Annals of Statistics</em>, 2019. (<a href="https://arxiv.org/abs/1610.01271">arxiv</a>)</p>
<p>Chernozhukov, Victor, Denis Chetverikov, Mert Demirer, Esther Duflo, Christian Hansen, Whitney Newey, and James Robins. Double/debiased machine learning for treatment and structural parameters. <em>The Econometrics Journal</em>, 2018.</p>
<p>Ghosal, Indrayudh, and Giles Hooker. Boosting Random Forests to Reduce Bias; One-Step Boosted Forest and its Variance Estimate. <em>arXiv preprint arXiv:1803.08000</em>, 2018.</p>
<p>Imbens, Guido W., and Donald B. Rubin. Causal inference in statistics, social, and biomedical sciences. <em>Cambridge University Press</em>, 2015.</p>
<p>Li, Fan, Kari Lock Morgan, and Alan M. Zaslavsky. Balancing covariates via propensity score weighting. <em>Journal of the American Statistical Association</em>, 2018.</p>
<p>Nie, Xinkun, and Stefan Wager. Learning Objectives for Treatment Effect Estimation. <em>arXiv preprint arXiv:1712.04912</em>, 2017.</p>
<p>Robins, James M., Andrea Rotnitzky, and Lue Ping Zhao. Estimation of regression coefficients when some regressors are not always observed. <em>Journal of the American statistical Association</em>, 1994.</p>
<p>Robinson, Peter M. Root-n-consistent semiparametric regression. <em>Econometrica</em>, 1988.</p>
<p>Van Der Laan, Mark J., and Daniel Rubin. Targeted maximum likelihood learning. <em>The International Journal of Biostatistics</em>, 2006.</p>
<p>Wager, Stefan, and Susan Athey. Estimation and inference of heterogeneous treatment effects using random forests. <em>Journal of the American Statistical Association</em>, 2018.</p>
</div>
</div>

  </div>

</div>



      <footer>
      <div class="copyright">
  <p>Developed by Julie Tibshirani, Susan Athey, Stefan Wager.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="https://pkgdown.r-lib.org/">pkgdown</a> 1.4.1.</p>
</div>

      </footer>
   </div>

  


  </body>
</html>


